# 安全机制

## A. 首选方案: 

通过https调用Api, 直接在请求中传递client_id与client_secret.

<table width="100%">
<tr><td width="20%">client_id</td><td>应用的Key</td></tr>
<tr><td width="20%">client_secret</td><td>key对应的secret</td></tr>
</table>

注意: client_id与client_secret一定要在GET的参数中进行传递.

<b>https</b>://openapi.example.com/api/path/to/method?<b>client_id=xxxx</b>&<b>client_secret=xxxxxx</b>

## B. 备选方案

访问非加密的http://地址, 需要对所有参数进行签名. 传递client_id与签名结果.

<table width="100%">
<tr><td width="20%">client_id</td><td>应用的Key</td></tr>
<tr><td width="20%">sign_method</td><td>md5</td></tr>
<tr><td width="20%">sign_time</td><td>当前时间戳</td></tr>
<tr><td width="20%">sign</td><td>SignToken, 下文详解</td></tr>
</table>

    SignToken = md5(SignString).toUpper()
    SignString = Join( [ClientSecret,Method,Path,headers,GetParams,PostParams,ClientSecret], '&' )

- Method = GET | POST | DELETE | PUT ...
- Path = /path/to/method
- headers = urnencode(HeaderKey1 + HeaderValue1 + HeaderKey1 + HeaderValue1 ...)
- GetParams = urnencode(GetKey1 + GetValue1 + GetKey2 + GetValue2 ...)
- PostParams = urnencode(PostKey1 + PostValue1 + PostKey2 + PostValue2 ...)
- ClientSecret = key的Secret密钥

说明:

- 其中headers, GetParams, PostParams需要首先对key进行a-z排序.
- 不是所有的header参数需要签名,  只对X-Api-开头以及Authorization进行签名
- signtoken是大写

urlencode规则:

RFC 3986 section 2.3
有效字符 = 字母 / 数字 / "-" / "." / "_" / "~"

- "!" -> %21
- "*" -> %2A
- "(" -> %28
- ")" -> %29
- " " -> %20

